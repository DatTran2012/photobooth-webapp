<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Photobooth ‚Äî Instax Style Selection</title>

<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;600;800&family=Varela+Round&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#f6f7fb;
    --panel:#fff;
    --accent1:#FFD1DC; /* Soft Pink */
    --accent2:#FFEBCD; /* Soft Peach */
    --accent3:#E6E6FA; /* Light Lavender */
    --primary:#FF69B4; /* Hot Pink/Rose */
    --muted:#9aa3b2;
    --instax-dark: #333333; 
    --instax-light: #F0F0F0; 
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family: 'Nunito', system-ui, sans-serif; background: linear-gradient(180deg,var(--bg),#ffffff 70%);
    color:#263238; -webkit-font-smoothing:antialiased;
    display:flex; align-items:flex-start; justify-content:center; padding:28px 16px;
  }

  /* Container ch·ª©a t·∫•t c·∫£ m√†n h√¨nh */
  .container{
    width:980px; max-width:100%; background:var(--panel); border-radius:14px; box-shadow:0 10px 30px rgba(20,30,50,0.08);
    padding:22px; 
    display:flex; 
    flex-direction: column;
    gap: 18px; 
  }

  /* ---------------------------------- M√ÄN H√åNH WELCOME ---------------------------------- */
  #welcomeScreen {
    width: 100%;
    display: flex; 
    align-items: center; 
    justify-content: center;
    min-height: 600px; /* Chi·ªÅu cao t·ªëi thi·ªÉu */
    flex-direction: column;
  }

  /* ---------------------------------- M√ÄN H√åNH CH·ª§P ---------------------------------- */
  #captureScreen {
    /* M·∫∑c ƒë·ªãnh ·∫©n, s·∫Ω ƒë∆∞·ª£c hi·ªÉn th·ªã b·∫±ng JS khi c·∫ßn */
    display: none;
    grid-template-columns: 1fr 320px; 
    gap: 18px;
    width: 100%;
  }

  /* Kh·ªëi Camera v√† Controls (Chi·∫øm c·ªôt 1 - ph·∫ßn m·ªü r·ªông) */
  #cameraAndControls { 
    grid-column: 1 / 2;
    display: flex; 
    flex-direction: column;
    align-items: center;
  }

  /* Kh·ªëi Settings Sidebar (Chi·∫øm c·ªôt 2 - ph·∫ßn c·ªë ƒë·ªãnh) */
  #settingsSidebar {
    grid-column: 2 / 3;
    display: flex;
    flex-direction: column;
    padding: 8px; 
    background: var(--bg); 
    border-radius: 10px;
  }

  /* ƒêi·ªÅu ch·ªânh Camera Wrap ƒë·ªÉ chi·∫øm 100% c·ªßa c·ªôt 1 */
  .camera-wrap{ 
    position:relative; 
    width:100%; 
    height: 600px; 
    max-width: none; 
    border-radius:14px; 
    overflow:hidden;
    box-shadow:0 6px 18px rgba(13,25,40,0.06); 
    background:linear-gradient(180deg,#111 0%, #333 100%); 
  }
  video#video { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; transform: scaleX(-1); }
  canvas#overlay{ position:absolute; inset:0; pointer-events:none; } 
  
  /* Controls (n√∫t Start, Reset) n·∫±m d∆∞·ªõi camera, cƒÉn gi·ªØa */
  .controls{ margin-top:12px; width:100%; display:flex; gap:8px; flex-wrap:wrap; justify-content:center; }
  
  /* Style chung cho n√∫t - c√≥ icon */
  .btn { 
    background: linear-gradient(180deg,var(--accent1),var(--accent3)); border:none; padding:10px 14px; border-radius:10px; cursor:pointer;
    box-shadow:0 6px 18px rgba(155,107,255,0.08); font-weight:700; color:#2b2335; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    gap: 6px; 
    transition: opacity 0.2s; /* Th√™m transition cho hi·ªáu ·ª©ng disable */
  }

  /* Style cho tr·∫°ng th√°i disable */
  .btn:disabled, select:disabled, input:disabled {
      opacity: 0.5;
      cursor: not-allowed;
  }
  
  .btn.secondary{ 
    background:transparent; border:1px solid #eee; box-shadow:none; font-weight:600; color:var(--muted); 
    padding: 8px 12px; 
  }

  .option-row{ margin-top:12px; display:flex; gap:8px; align-items:center; justify-content:center; flex-wrap:wrap; }
  select, input[type=number], input[type=text]{ 
    padding:8px 10px; border-radius:8px; border:1px solid #eee; background:#fff; outline:none; font-weight:600; 
    transition: opacity 0.2s; /* Th√™m transition cho hi·ªáu ·ª©ng disable */
  }
  
  .left { display: none; } 

  /* ---------------------------------- M√ÄN H√åNH REVIEW ---------------------------------- */
  #reviewScreen {
      width: 100%;
      display: none; 
      flex-direction: column;
  }
  .review-inner { padding:8px 14px; display:flex; flex-direction:column; }
  
  /* Thi·∫øt l·∫≠p ri√™ng cho kh·ªëi settings tr√™n Review ƒë·ªÉ kh√¥ng c√≥ padding tr√™n d∆∞·ªõi*/
  #reviewSettings { padding-top: 0; padding-bottom: 0; }
  
  .preview-grid{ display:grid; grid-template-columns:repeat(2,1fr); gap:10px; margin-top:8px; }
  
  /* ƒê√£ c·∫≠p nh·∫≠t: B·ªè aspect-ratio c·ª©ng, s·∫Ω ƒë∆∞·ª£c set b·∫±ng JS d·ª±a tr√™n t·ª∑ l·ªá film Instax (gi·ªù l√† 1:1) */
  .instax-thumb-frame {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%; 
    /* ƒê√£ b·ªè padding d∆∞·ªõi ƒë·ªÉ gi·∫£m m√¥ ph·ªèng ch√¢n tr·∫Øng Instax */
    padding: 6px 6px 6px 6px; 
    background: #FFFFFF;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    position: relative;
    overflow: hidden;
    cursor: pointer; 
  }
  .instax-thumb-frame img { 
    width: 100%; 
    height: 100%; 
    object-fit: cover; 
    border-radius: 3px; 
    box-shadow: none; 
  }
  .preview-grid img { 
    height: auto; 
  }

  .final-wrap{ margin-top:12px; display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap; }
  
  /* Khung Final Preview s·∫Ω nh·∫≠n aspect-ratio ƒë·ªông t·ª´ JS */
  /* FIX: TƒÉng max-width ƒë·ªÉ ·∫£nh hi·ªÉn th·ªã ƒë·∫πp h∆°n v√† kh√¥ng b·ªã co qu√° nh·ªè */
  .final-preview{ 
    max-width:300px; 
    border-radius:8px; overflow:hidden; background:#f9f9fa; 
    display:flex; align-items:center; justify-content:center; 
    box-shadow:0 8px 30px rgba(30,40,60,0.06); 
    position: relative; 
    width: auto; 
    height: auto; 
    /* ƒê√£ b·ªè aspect-ratio m·∫∑c ƒë·ªãnh */
  }
  .final-preview img{ 
    width:100%; 
    height:100%; 
    object-fit:cover; 
  }

  .small{ font-size:13px; color:var(--muted); }
.countdown { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none;
    font-size:92px; color:white; font-weight:900; text-shadow:0 8px 30px rgba(0,0,0,0.6); }

  .theme-line{ display:flex; align-items:center; gap:8px; justify-content:space-between; margin-top:8px;}
  .theme-tag{ background:linear-gradient(90deg,var(--accent2),var(--accent1)); padding:6px 10px; border-radius:999px; font-weight:700; color:#3b2b47; box-shadow:0 6px 20px rgba(255,105,180,0.06); }

  footer{ margin-top:12px; font-size:12px; color:var(--muted); text-align:center; grid-column:1/-1; }

  /* ---------------------------------- T·ªêI ∆ØU MOBILE ---------------------------------- */
  @media (max-width:900px){
    .container{ width:92%; }
    
    #welcomeScreen { min-height: 400px; }

    #captureScreen {
        grid-template-columns: 1fr; 
        gap: 0;
    }
    
    #cameraAndControls { grid-column: 1 / -1; }
    .camera-wrap{ height: 420px; }

    #settingsSidebar {
        grid-column: 1 / -1; 
        margin-top: 18px; 
        padding: 0; 
        background: transparent;
        border-radius: 0;
    }
    
    .theme-line, .option-row { padding: 0 10px; }

    /* FIX: ƒêi·ªÅu ch·ªânh max-width tr√™n tablet/m√†n h√¨nh nh·ªè ƒë·ªÉ ·∫£nh gh√©p kh√¥ng b·ªã co qu√° nhi·ªÅu */
    .final-preview{ max-width: 220px; } 
    .final-wrap{ justify-content: center; } 
  }

  @media (max-width:500px){
    body{ padding: 12px 6px; }
    .container{ padding: 10px; width: 100%; }
    
    .camera-wrap{ height: 380px; }
    
    .controls{ justify-content: center; gap: 4px; }
    
    /* ƒêi·ªÅu ch·ªânh n√∫t cho mobile */
    .btn { font-size: 13px; padding: 8px 10px; flex-grow: 1; min-width: 45%; }
    .btn#startBtn { min-width: 60%; } 
    
    .option-row{ flex-direction: column; align-items: stretch; margin-top: 8px; }
    .option-row label.small { width: 100%; text-align: left; margin-bottom: 2px; }
    
    .final-wrap{ flex-direction: column; gap: 12px; align-items: center; margin-top: 10px; width: 100%; overflow-x: hidden; }
    .final-wrap > div:first-child {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center; 
        padding: 0 10px;
        box-sizing: border-box;
    }
    
    .final-preview { max-width: 100%; width: 100%; height: auto; flex-shrink: 0; }
    
    .review-inner { padding: 4px; overflow-x: hidden; }
    #finalActions { padding-top: 0 !important; }
  }
</style>
</head>
<body>

<div class="container">
  
  <div id="welcomeScreen" style="display: flex;">
      <div style="text-align:center; padding: 40px 20px;">
          <h1 style="color: var(--primary); font-size: 2.2em; margin-bottom: 5px;">
              üì∏ Photobooth Instax Studio
          </h1>
          <p style="color: var(--muted); font-size: 1.1em; max-width: 500px; margin: 0 auto 30px;">
              S·∫µn s√†ng t·∫°o ·∫£nh strip 4 pose phong c√°ch Photobooth v·ªõi c√°c t√πy ch·ªçn n·ªÅn v√† layout ƒë·ªôc ƒë√°o.
          </p>
          
          <div style="display: inline-block; text-align: left; background: var(--bg); padding: 18px 25px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); margin-bottom: 30px;">
              <strong style="color: #3b2b47;">H∆∞·ªõng d·∫´n:</strong>
              <ul style="list-style: none; padding: 0; margin: 10px 0 0; font-size: 0.95em;">
                  <li style="margin-bottom: 5px;">‚úÖ B·∫•m **B·∫Øt ƒê·∫ßu** v√† c·∫•p quy·ªÅn Camera.</li>
                  <li style="margin-bottom: 5px;">‚úÖ ƒê·∫øm ng∆∞·ª£c **3 gi√¢y** gi·ªØa m·ªói l·∫ßn ch·ª•p (t·ªïng 4 pose).</li>
                  <li>‚úÖ ·∫¢nh ch·ª•p c·ªë ƒë·ªãnh **T·ª∑ l·ªá 1:1 (Square)**. T√πy ch·ªânh **N·ªÅn/Layout** sau khi ch·ª•p xong.</li>
              </ul>
          </div>

          <button class="btn" id="startPhotoboothBtn" style="font-size: 1.2em; padding: 12px 20px;">
              B·∫Øt ƒê·∫ßu Ch·ª•p ·∫¢nh <span style="font-size: 1.1em;">‚Üí</span>
          </button>
      </div>
  </div>

  <div id="captureScreen">
    
    <div id="cameraAndControls">
        <div class="camera-wrap" id="cameraWrap">
            <video id="video" autoplay playsinline muted></video>
            <canvas id="overlay"></canvas>
            <div class="countdown" id="countdown" style="display:none"></div>
        </div>

        <div class="controls">
            <button class="btn" id="startBtn">
                <span style="font-size: 1.2em; line-height: 1;">üì∏</span> Start Photobooth
            </button>
            <button class="btn secondary" id="redoBtn">
                <span style="font-size: 1.1em; line-height: 1;">üóëÔ∏è</span> Reset ·∫¢nh Ch·ª•p
            </button> 
            <button class="btn secondary" id="stopCamBtn">
                <span style="font-size: 1.1em; line-height: 1;">üõë</span> T·∫Øt Camera
            </button> 
            <button class="btn secondary" id="switchCamBtn">
                <span style="font-size: 1.1em; line-height: 1;">üîÑ</span> ƒê·ªïi Camera
            </button> 
            <button class="btn secondary" id="refreshBtn">
                <span style="font-size: 1.1em; line-height: 1;">‚ö°</span> Refresh Trang
            </button> 
        </div>
    </div>


    <div id="settingsSidebar">
      <div style="font-weight:700; color: #3b2b47; margin-bottom: 10px;">T√ôY CH·ªåN CH·ª§P ·∫¢NH</div>
      
      <div class="option-row" style="width:100%; justify-content:space-between; flex-wrap:nowrap; margin-top:12px;">
        <label class="small">Timer (gi·ªØa m·ªói pose):</label>
        <input id="intervalSec" type="number" value="2" min="1" style="width:70px"/>
      </div>
      
      <div class="theme-line" style="width:100%; margin-top:10px;">
        <div class="theme-tag">Photobooth - Made by Dat Tran</div>
        <div class="small">Photobooth Studio ‚Ä¢ 4 pose</div>
      </div>
    </div>
  </div>

  <div id="reviewScreen">
    <button class="btn secondary" id="backToCaptureBtn" style="margin-bottom: 12px; margin-left: 10px;">
        <span style="font-size: 1.1em; line-height: 1;">‚Üê</span> Quay l·∫°i trang Ch·ª•p ·∫¢nh
    </button>
    
    <div id="reviewSettings" class="review-inner">
      <div style="font-weight:700; color: #3b2b47; margin-bottom: 10px;">T√ôY CH·ªåN ·∫¢NH GH√âP (MERGE)</div>

      <div class="option-row" style="width:100%; margin-top:0px;">
          <label class="small">Background Strip:</label>
          <select id="backgroundSelect" style="flex:1;">
            <option value="default">M·∫∑c ƒë·ªãnh (Tr·∫Øng T·ªëi Gi·∫£n)</option>
            <option value="soft_rose_gradient">‚ù§Ô∏è Gradient H·ªìng Kem D·ªãu</option>
            <option value="romantic_red_velvet">üåπ Nhung ƒê·ªè L√£ng M·∫°n</option>
            <option value="lavender_haze_blur">‚ú® Xanh T√≠m S∆∞∆°ng M·ªù</option>
            <option value="sweetheart_pink_dots">üíñ Ch·∫•m Bi Tr√°i Tim H·ªìng</option>
            <option value="sunset_kiss_gradient">üåÖ Gradient H√¥n Chi·ªÅu T√†</option>
            <option value="champagne_toast">ü•Ç V√†ng Kem √Ånh Kim</option>
            <option value="blush_watercolor">üå∏ M√†u N∆∞·ªõc H·ªìng Ph·ªõt</option>
            <option value="mint_love_stripes">üåø S·ªçc Xanh Mint D·ªãu M√°t</option>
            <option value="starry_night_light">üåå B·∫ßu Tr·ªùi ƒê√™m L·∫•p L√°nh</option>
            <option value="coral_dream">üß° San H√¥ M∆° M√†ng</option>
            <option value="berry_smoothie">üíú H·ªìng M√¢m X√¥i T∆∞∆°i T·∫Øn</option>
            <option value="lilac_blossom_texture">üîÆ Texture V·∫£i T√≠m Lilac</option>
            <option value="peachy_glow">üçë Cam ƒê√†o R·∫°ng R·ª°</option>
            <option value="cotton_candy_swirl">üç≠ Xo√°y K·∫πo B√¥ng G√≤n Pastel</option>
            <option value="valentines_day_hearts">üíå H·ªça Ti·∫øt Tr√°i Tim L·ªÖ T√¨nh Nh√¢n</option>
            <option value="aurora_pink_blue">üåà B·∫Øc C·ª±c Quang H·ªìng Xanh</option>
            <option value="lemonade_pink">‚òÄÔ∏è Gradient V√†ng H·ªìng T∆∞∆°i</option>
            <option value="dreamy_cloud_pastel">‚òÅÔ∏è H·ªça Ti·∫øt M√¢y B·ªìng B·ªÅnh</option>
            <option value="minimal_white_texture">‚¨ú Texture Tr·∫Øng T·ªëi Gi·∫£n (C·ªï ƒëi·ªÉn)</option>
            <option value="stripes_bw">‚ñ™Ô∏è S·ªçc ƒêen Tr·∫Øng (C·ªï ƒëi·ªÉn)</option> 
            <option value="fuji_classic_clean">üü¶ Fuji Classic Clean (Footer Xanh)</option>
          </select>
      </div>
      
      <div class="option-row" style="width:100%; margin-top:10px;">
          <label class="small">Khung Overlay (cho m·ªói ·∫£nh):</label>
          <select id="overlaySelect" style="flex:1;">
            <option value="none">Kh√¥ng c√≥ (Clean)</option>
            <option value="heart_corners">1. G√≥c Tr√°i Tim (H·ªìng)</option>
            <option value="film_damage">2. B·ª•i & V·∫øt X∆∞·ªõc (C·ªï ƒëi·ªÉn)</option>
            <option disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NHI·ªÑU & C·ªî ƒêI·ªÇN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>
            <option value="film_grain_light">3. H·∫°t Nhi·ªÖu Film (Nh·∫π)</option>
            <option value="film_grain_heavy">4. H·∫°t Nhi·ªÖu Film (N·∫∑ng)</option>
            <option value="vintage_sepia_light">5. M√†u N√¢u ƒê·ªè (Sepia Nh·∫π)</option>
            <option value="faded_matte">6. Hi·ªáu ·ª©ng M·ªù Nh·∫°t (Matte)</option>
            <option value="dust_scratches_medium">7. B·ª•i & V·∫øt X∆∞·ªõc (Trung b√¨nh)</option>
            
            <option disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ √ÅNH S√ÅNG ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>
            <option value="golden_light_leak">8. R√≤ R·ªâ √Ånh S√°ng (V√†ng)</option>
            <option value="sunset_light_leak">9. R√≤ R·ªâ √Ånh S√°ng (Ho√†ng H√¥n)</option>
            <option value="soft_bokeh">10. Hi·ªáu ·ª©ng Bokeh (M·ªù nh·∫π)</option>
            <option value="blue_vignette">11. T·ªëi G√≥c (Xanh L·∫°nh)</option>
            <option value="rainbow_prism">12. V·ªát LƒÉng K√≠nh (C·∫ßu V·ªìng)</option>
            <option value="film_burn_top">13. Ch√°y Film (Top)</option>
            
            <option disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ KHUNG & H√åNH D·∫†NG ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>
            <option value="polaroid_border_thin">14. Khung Trong (Polaroid M·ªèng)</option>
            <option value="black_frame_thin">15. Vi·ªÅn ƒêen M·ªèng</option>
            <option value="white_cross_hatch">16. G·∫°ch Ch√©o Tr·∫Øng (Texture)</option>
            <option value="heart_shaped_mask">17. Mask H√¨nh Tr√°i Tim (Vi·ªÅn)</option>
            <option value="scribble_corners">18. V·∫Ω Ngu·ªách Ngo·∫°c (G√≥c)</option>
            <option value="tape_strip_top">19. D·∫£i BƒÉng D√≠nh (Top)</option>
            
            <option disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HI·ªÜU ·ª®NG ƒê·∫∂C BI·ªÜT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>
            <option value="holographic_glitch">20. L·ªói Hologram (Glitch)</option>
            <option value="half_tone_dots">21. Ch·∫•m M·ª±c (Halftone)</option>
            <option value="glitter_sparkle">22. L·∫•p L√°nh (Gi·∫£)</option>
          </select>
          </div>
      
      <div class="option-row" style="width:100%; justify-content:flex-start; flex-wrap:nowrap; margin-top:10px;">
        <label class="small" style="white-space:nowrap; margin-left:10px;">Text Strip:</label>
        <input id="customStripText" type="text" value="INSTAX MOMENT" style="flex:1;" maxlength="30" placeholder="VD: INSTAX MOMENT"/>
      </div>
      
      <div class="option-row" style="width:100%; margin-top:10px; margin-bottom: 10px;">
        <label class="small">Layout In ·∫¢nh:</label>
        <select id="layoutSelect" style="flex:1;">
          <option value="vertical">1. D·ªçc (Strip) - Fixed 1:1 Photo</option>
          <option value="grid">2. L∆∞·ªõi (2x2) - Fixed 1:1 Photo</option>
        </select>
      </div>

    </div>
    
    <div class="review-inner">
      <div style="display:flex; gap:10px; align-items:center; justify-content:space-between;">
        <div>
          <strong>Preview (4 pose)</strong>
          <div class="small">Click v√†o khung ·∫£nh ƒë·ªÉ download t·ª´ng t·∫•m</div>
        </div>
        <div class="small" id="stripSizeText">Strip size: Dynamic Size</div> 
      </div>

      <div class="preview-grid" id="previewGrid" style="margin-top:8px;"></div>
      
      <div class="final-wrap">
        <div>
          <div style="font-weight:700">Final Review (·∫¢nh ƒë√£ gh√©p - Merge)</div>
          <div class="final-preview" id="finalPreview">
            <div class="small">Ch∆∞a c√≥ ·∫£nh</div>
          </div>
        </div>
        <div id="finalActions" style="display:none; flex-direction:column; gap:8px; align-items:flex-start; padding-top:20px;">
          <div class="small">·∫¢nh ƒë√£ gh√©p xong.</div>
          <button class="btn" id="downloadFinalBtn">
            <span style="font-size: 1.1em; line-height: 1;">üì•</span> Download Final
          </button>
        </div>
      </div>
    </div>
  </div>

  <footer>Made for you ‚Äî Photobooth Square ‚Ä¢ Timezone: Asia/Ho_Chi_Minh</footer>
</div>

<script>
/* ---------- Photobooth (fixed & overlay sizing) ---------- */
const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const overlayCtx = overlay.getContext('2d');
const previewGrid = document.getElementById('previewGrid');
const finalPreview = document.getElementById('finalPreview'); 
const countdownEl = document.getElementById('countdown');
// const frameSelect = document.getElementById('frameSelect'); // ƒê√É B·ªé
const layoutSelect = document.getElementById('layoutSelect'); 
const backgroundSelect = document.getElementById('backgroundSelect'); 
const customStripText = document.getElementById('customStripText');
const stripSizeText = document.getElementById('stripSizeText'); 
const finalActionsEl = document.getElementById('finalActions'); 

// NEW VARIABLES FOR OVERLAY/STICKER
const overlaySelect = document.getElementById('overlaySelect'); 
// END NEW VARIABLES

// NEW UI ELEMENTS FOR SCREEN SWITCHING
const welcomeScreen = document.getElementById('welcomeScreen');
const captureScreen = document.getElementById('captureScreen');
const reviewScreen = document.getElementById('reviewScreen');
const backToCaptureBtn = document.getElementById('backToCaptureBtn');

// NEW: Capture Controls & Settings elements to disable during the sequence
const startBtn = document.getElementById('startBtn');
const redoBtn = document.getElementById('redoBtn');
const stopCamBtn = document.getElementById('stopCamBtn');
const switchCamBtn = document.getElementById('switchCamBtn');
const refreshBtn = document.getElementById('refreshBtn');
const intervalSec = document.getElementById('intervalSec');
const startPhotoboothBtn = document.getElementById('startPhotoboothBtn'); // N√∫t B·∫Øt ƒê·∫ßu ·ªü m√†n h√¨nh Welcome

const controlsToDisable = [
    startBtn, redoBtn, stopCamBtn, switchCamBtn, refreshBtn, 
    // frameSelect, // ƒê√É B·ªé
    intervalSec, startPhotoboothBtn
];

let captures = [];
const timeZone = 'Asia/Ho_Chi_Minh';
let stream = null;
let currentFacingMode = 'user'; 
let finalImageDataUrl = null; 

// CONSTANTS
const INNER_BORDER = 3; 
// C·∫¨P NH·∫¨T THEO Y√äU C·∫¶U: TƒÉng kho·∫£ng c√°ch gi·ªØa c√°c ·∫£nh trong strip d·ªçc
const VERT_GAP = 40; 

// NEW BASE CONSTANTS for dynamic sizing
const BASE_FRAME_H = 450; // Chi·ªÅu cao chu·∫©n cho m·ªôt t·∫•m ·∫£nh
const VERT_MARGIN_X = 30; // L·ªÅ X cho strip d·ªçc
// NEW CONSTANT: L·ªÅ tr√™n/d∆∞·ªõi cho kh·ªëi ·∫£nh trong strip d·ªçc (T∆∞∆°ng ·ª©ng v·ªõi VERT_GAP)
const VERT_MARGIN_Y = 40; 
const VERT_TEXT_H = 250; // Chi·ªÅu cao khu v·ª±c ch·ªØ strip d·ªçc
const GRID_OUTER_PADDING = 40; // L·ªÅ ngo√†i cho l∆∞·ªõi (s·ª≠ d·ª•ng thay cho GRID_MARGIN)
const GRID_GAP = 30; // Kho·∫£ng c√°ch gi·ªØa c√°c ·∫£nh (ngang/d·ªçc)
const GRID_TEXT_H = 250; // Chi·ªÅu cao khu v·ª±c ch·ªØ cho l∆∞·ªõi

// devicePixelRatio helper
function getDPR(){ return window.devicePixelRatio || 1; }

/* -------------------- T·ª∂ L·ªÜ ·∫¢NH CH·ª§P (C·ªê ƒê·ªäNH 1:1) -------------------- */

// H√†m l·∫•y t·ª∑ l·ªá (W/H) c·ªßa khu v·ª±c ·∫£nh b√™n trong film (d√πng cho live preview & drawing)
function getInstaxPhotoRatio(frameStyle) {
    // Photo Area Ratios (W/H) - C·ªë ƒë·ªãnh 1:1 (Square) theo y√™u c·∫ßu b·ªè tu·ª≥ ch·ªçn
    return 1.0; 
}

// H√†m l·∫•y t·ª∑ l·ªá (W/H) c·ªßa to√†n b·ªô film Instax (·∫£nh + ch√¢n tr·∫Øng)
function getInstaxFilmRatio(frameStyle) {
    // Film Area Ratios (W/H) - D√πng t·ª∑ l·ªá 1:1 cho thumbnail (ƒë√£ b·ªè m√¥ ph·ªèng film)
    return 1.0;
}

// C·∫≠p nh·∫≠t t·ª∑ l·ªá cho t·∫•t c·∫£ thumbnails tr√™n m√†n h√¨nh review
// D√πng t·ª∑ l·ªá 1:1 (ƒë√£ b·ªè m√¥ ph·ªèng film)
function updateThumbnailAspectRatios() {
    const numericRatio = getInstaxFilmRatio('square'); 

    const thumbs = document.querySelectorAll('.instax-thumb-frame');
    thumbs.forEach(thumb => {
        // S·ª≠ d·ª•ng numericRatio / 1 cho CSS aspectRatio (fixed 1:1)
        thumb.style.aspectRatio = `${numericRatio} / 1`; 
    });
}

/* ----------------- END T·ª∂ L·ªÜ ·∫¢NH CH·ª§P LOGIC ------------------ */


/* --------------- UI SWITCHING LOGIC (GI·ªÆ NGUY√äN) --------------- */

function showWelcomeScreen() {
    captureScreen.style.display = 'none';
    reviewScreen.style.display = 'none';
    welcomeScreen.style.display = 'flex';
    resetAll(); 
    stopCamera(); 
}

function showReviewScreen() {
    welcomeScreen.style.display = 'none';
    captureScreen.style.display = 'none';
    reviewScreen.style.display = 'flex'; 
    
    // NEW: ƒê·∫£m b·∫£o t·ª∑ l·ªá thumbnails ch√≠nh x√°c khi chuy·ªÉn m√†n h√¨nh
    updateThumbnailAspectRatios(); 

    window.scrollTo({ top: 0, behavior: 'smooth' }); 
}

function showCaptureScreen() {
    welcomeScreen.style.display = 'none';
    reviewScreen.style.display = 'none';
    // ƒê·∫∑t captureScreen th√†nh 'grid' ƒë·ªÉ √°p d·ª•ng b·ªë c·ª•c 2 c·ªôt (Camera m·ªü r·ªông + Sidebar)
    captureScreen.style.display = 'grid'; 
}

/* --------------- END UI SWITCHING LOGIC --------------- */

// start camera
async function startCamera(){
  try {
    console.log(`Y√™u c·∫ßu camera: ${currentFacingMode === 'user' ? 'Tr∆∞·ªõc' : 'Sau'}...`);
    stream = await navigator.mediaDevices.getUserMedia({ 
      video: { 
        width: { ideal: 1280 }, 
        height: { ideal: 720 }, 
        facingMode: currentFacingMode 
      }, 
      audio:false 
    });
    video.srcObject = stream;
    
    await new Promise(resolve => {
        if (video.readyState >= 2) { 
            resolve();
        } else {
            video.addEventListener('loadedmetadata', resolve, { once: true });
        }
    });

    await video.play();
    resizeOverlay(); 
    drawFrameLoop();
    console.log(`Camera ${currentFacingMode === 'user' ? 'Tr∆∞·ªõc' : 'Sau'} ƒë√£ b·∫≠t`);

    video.style.transform = currentFacingMode === 'user' ? 'scaleX(-1)' : 'none';

  } catch(e) {
    console.error('startCamera error', e);
    const name = e && e.name ? e.name : 'UnknownError';
    const msg = e && e.message ? e.message : String(e);
    alert('Kh√¥ng th·ªÉ truy c·∫≠p camera: ' + name + ' ‚Äî ' + msg + '\n\nKi·ªÉm tra: (1) ch·∫°y tr√™n localhost/https (2) tr√¨nh duy·ªát cho ph√©p quy·ªÅn camera (3) kh√¥ng b·ªã app kh√°c chi·∫øm d·ª•ng).');
  }
}

function stopCamera(){
  try{
    if (stream) {
      stream.getTracks().forEach(t=>t.stop());
      stream = null;
      console.log('Camera ƒë√£ t·∫Øt');
    }
  } catch(e){}
}

async function switchCamera() {
    if (captures.length > 0) {
        alert('B·∫°n ch·ªâ c√≥ th·ªÉ chuy·ªÉn ƒë·ªïi camera tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu ch·ª•p. H√£y b·∫•m "Reset ·∫¢nh Ch·ª•p" n·∫øu mu·ªën ƒë·ªïi.');
        return;
    }
    if (stream) {
        stopCamera();
    }
    currentFacingMode = (currentFacingMode === 'user' ? 'environment' : 'user');
    await startCamera();
}

function resizeOverlay(){
  const dpr = getDPR();
  const vcw = video.clientWidth;
  const vch = video.clientHeight;
  const vw = video.videoWidth;
  const vh = video.videoHeight;
  
  if (vw === 0 || vh === 0 || vcw === 0 || vch === 0) return;

  const aspect = vw / vh;
  const wrapAspect = vcw / vch;

  let newW, newH, xOffset, yOffset;

  // CƒÉn gi·ªØa video trong wrap area (object-fit: cover)
  if (aspect > wrapAspect) {
    newH = vch;
    newW = vch * aspect;
    xOffset = (vcw - newW) / 2;
    yOffset = 0;
  } else {
    newW = vcw;
    newH = vcw / aspect;
    xOffset = 0;
    yOffset = (vch - newH) / 2;
  }

  // C·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc canvas (theo k√≠ch th∆∞·ªõc hi·ªÉn th·ªã th·ª±c t·∫ø c·ªßa video)
  overlay.width = vcw * dpr;
  overlay.height = vch * dpr;
  overlay.style.width = vcw + 'px';
  overlay.style.height = vch + 'px';

  // C·∫≠p nh·∫≠t transformation ƒë·ªÉ v·∫Ω
  overlayCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
  overlayCtx.clearRect(0, 0, vcw, vch);
  
  // Thi·∫øt l·∫≠p bi·∫øn transform cho drawing (d√πng ƒë·ªÉ v·∫Ω khung ·∫£nh v√† ng√†y gi·ªù)
  // Bi·∫øn n√†y s·∫Ω ƒë∆∞·ª£c d√πng trong drawInstaxGuide
  overlayCtx.globalTransform = {
      scaleX: newW / vw, 
      scaleY: newH / vh, 
      offsetX: xOffset,
      offsetY: yOffset,
      dpr: dpr,
      vcw: vcw, 
      vch: vch
  };
}

function drawFrameLoop(){
  // T·∫Øt/M·ªü camera kh√¥ng c·∫ßn g·ªçi drawFrameLoop n·ªØa
  if (stream) { 
    drawInstaxGuide(overlayCtx, video.clientWidth, video.clientHeight);
    drawDateTime(overlayCtx, video.clientWidth, video.clientHeight);
    requestAnimationFrame(drawFrameLoop); 
  }
}

function roundRect(ctx, x, y, w, h, r) {
    // B·∫Øt bu·ªôc w v√† h ph·∫£i l√† d∆∞∆°ng tr∆∞·ªõc khi g·ªçi h√†m n√†y
    // L·ªói IndexSizeError x·∫£y ra n·∫øu r tr·ªü th√†nh √¢m
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
}

function drawInstaxGuide(ctx, w, h){
    // B·ªè tu·ª≥ ch·ªçn Instax Frame Ratio, c·ªë ƒë·ªãnh t·ª∑ l·ªá ·∫£nh l√† 1:1 (Square Photo Area)
    const frameStyle = 'square'; 
    const targetRatio = getInstaxPhotoRatio(frameStyle); // 1.0
    
    let innerColor = 'rgba(255, 255, 255, 0.4)'; 
    const pad = 12;
    const cornerRadius = 18;

    ctx.save();
    
    // 1. V·∫Ω khung ngo√†i (c·ªë ƒë·ªãnh)
    const x_outer = pad;
    const y_outer = pad;
    const w_outer = w - 2 * pad;
    const h_outer = h - 2 * pad;
    
    // FIX: B·ªï sung ki·ªÉm tra an to√†n ƒë·ªÉ ngƒÉn l·ªói IndexSizeError n·∫øu camera wrap qu√° nh·ªè
    if (w_outer <= 0 || h_outer <= 0) {
        ctx.restore();
        return; 
    }
    
    roundRect(ctx, x_outer, y_outer, w_outer, h_outer, cornerRadius);
    ctx.lineWidth = 4;
    ctx.strokeStyle = innerColor;
    ctx.stroke();

    // 2. T√≠nh to√°n v√† v·∫Ω khung ·∫¢NH B√äN TRONG (Photo Area) d·ª±a tr√™n t·ª∑ l·ªá c·ªë ƒë·ªãnh (1:1)
    // T·ª∑ l·ªá video l√† vw/vh. T·ª∑ l·ªá ·∫£nh mong mu·ªën l√† targetRatio (1.0).
    const maxPhotoW = w_outer - 2 * pad; 
    const maxPhotoH = h_outer - 2 * pad; 
    
    let finalPhotoW, finalPhotoH;
    
    // CƒÉn t·ª∑ l·ªá ·∫£nh (targetRatio) v√†o khu v·ª±c xem (maxPhotoW x maxPhotoH)
    if ((maxPhotoW / maxPhotoH) > targetRatio) {
        // Chi·ªÅu cao l√† gi·ªõi h·∫°n
        finalPhotoH = maxPhotoH;
        finalPhotoW = Math.round(finalPhotoH * targetRatio);
    } else {
        // Chi·ªÅu r·ªông l√† gi·ªõi h·∫°n
        finalPhotoW = maxPhotoW;
        finalPhotoH = Math.round(finalPhotoW / targetRatio);
    }

    const x_inner = x_outer + pad + (maxPhotoW - finalPhotoW) / 2;
    const y_inner = y_outer + pad + (maxPhotoH - finalPhotoH) / 2;

    // V·∫Ω khung n√©t ƒë·ª©t cho khu v·ª±c ·∫£nh (Photo Area)
    ctx.strokeStyle = innerColor;
    ctx.lineWidth = 2;
    ctx.setLineDash([8, 8]);
    ctx.strokeRect(x_inner, y_inner, finalPhotoW, finalPhotoH);
    
    ctx.setLineDash([]);
    ctx.restore();
}

function drawDateTime(ctx, w, h) {
  ctx.save();
  ctx.font = '600 14px Nunito, system-ui, sans-serif';
  let textColor = 'rgba(255,255,255,0.9)';
  ctx.fillStyle = textColor;
  ctx.textAlign = 'left';
  ctx.fillText(getFormattedNow(), 14, h - 18);
  ctx.restore();
}

function getFormattedNow(){
  const now = new Date();
  const fmt = new Intl.DateTimeFormat('vi-VN', { 
    timeZone: timeZone, 
    year:'numeric', 
    month:'2-digit', 
    day:'2-digit', 
    hour:'2-digit', 
    minute:'2-digit', 
    second:'2-digit' 
  });
  return fmt.format(now).replace(',', '');
}

// NEW: Functions to control capture buttons
function disableControls() {
    controlsToDisable.forEach(ctrl => {
        if (ctrl) ctrl.disabled = true;
    });
}

function enableControls() {
    controlsToDisable.forEach(ctrl => {
        if (ctrl) ctrl.disabled = false;
    });
}

// C·∫≠p nh·∫≠t: Khi thay ƒë·ªïi background/text/layout, c·∫≠p nh·∫≠t final review realtime
backgroundSelect.addEventListener('change', () => {
    if (captures.length > 0 && reviewScreen.style.display !== 'none') mergeAndShowFinal();
});
customStripText.addEventListener('input', () => {
    if (captures.length > 0 && reviewScreen.style.display !== 'none') mergeAndShowFinal();
});
// Listener for layout change - C·∫≠p nh·∫≠t final review realtime
layoutSelect.addEventListener('change', () => {
    // Kh√¥ng c·∫ßn c·∫≠p nh·∫≠t stripSizeText ·ªü ƒë√¢y n·ªØa, v√¨ mergeStrip s·∫Ω l√†m vi·ªác ƒë√≥
    if (captures.length > 0 && reviewScreen.style.display !== 'none') mergeAndShowFinal();
    else resetAll();
});
// NEW: Listener cho overlaySelect
overlaySelect.addEventListener('change', () => {
    if (captures.length > 0 && reviewScreen.style.display !== 'none') mergeAndShowFinal();
});


document.getElementById('downloadFinalBtn').addEventListener('click', () => {
  if (finalImageDataUrl) {
    triggerDownload(finalImageDataUrl, `photobooth_strip_${dateForFilename()}.png`);
  } else {
    alert('Kh√¥ng t√¨m th·∫•y ·∫£nh ƒë√£ gh√©p ƒë·ªÉ t·∫£i xu·ªëng. Vui l√≤ng ch·ª•p ·∫£nh tr∆∞·ªõc.');
  }
});

backToCaptureBtn.addEventListener('click', showWelcomeScreen); // Quay l·∫°i m√†n h√¨nh Welcome

function sleep(ms){
  return new Promise(r=>setTimeout(r,ms));
}

async function startPhotobooth(){
    // B·∫Øt ƒë·∫ßu: V√¥ hi·ªáu h√≥a controls
    disableControls();
    
    captures = [];
    previewGrid.innerHTML = '';
    finalPreview.innerHTML = '<div class="small">ƒêang ch·ª•p...</div>';
    finalActionsEl.style.display = 'none';

    // ƒê·∫£m b·∫£o ƒëang ·ªü m√†n h√¨nh ch·ª•p
    if (captureScreen.style.display === 'none') {
        showCaptureScreen();
    }
    
    const interval = Math.max(1, parseInt(document.getElementById('intervalSec').value||2,10));
    const stepLabels = ['FIRST', 'SECOND', 'THIRD', 'FINAL'];

    for (let i=1;i<=4;i++){
        const label = stepLabels[i - 1] + ' PHOTO';
        await doCountdown(3, label);
        const img = takeSnapshot();
        captures.push(img);
        addThumbnail(img, i);
        // Sau khi ch·ª•p ·∫£nh th·ª© 1, 2, 3 th√¨ delay th√™m interval gi√¢y
        if (i < 4 && interval > 0) {
            countdownEl.style.display = 'flex';
            countdownEl.style.flexDirection = 'row';
            countdownEl.innerHTML = `<span style="font-size: 0.35em; font-weight: 600; opacity: 0.8;">WAITING</span><span style="line-height: 1; margin-left: 10px;">${interval}s</span>`;
            await sleep(interval * 1000);
            countdownEl.textContent = '';
            countdownEl.style.display = 'none';
        }
    }
    
    // K·∫øt th√∫c: K√≠ch ho·∫°t l·∫°i controls
    enableControls();
    
    // Chuy·ªÉn sang m√†n h√¨nh review v√† t·∫°o ·∫£nh cu·ªëi
    showReviewScreen();
    mergeAndShowFinal();
}

// NEW: H√†m takeSnapshot ƒë·ªÉ ch·ª•p ·∫£nh 1:1
function takeSnapshot() {
    const videoWidth = video.videoWidth;
    const videoHeight = video.videoHeight;
    const targetRatio = getInstaxPhotoRatio('square'); // 1.0

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // T√≠nh to√°n k√≠ch th∆∞·ªõc c·∫Øt (crop)
    const videoRatio = videoWidth / videoHeight;
    let cropX = 0, cropY = 0, cropW = videoWidth, cropH = videoHeight;
    
    if (videoRatio > targetRatio) {
        // Video r·ªông h∆°n (c·∫ßn c·∫Øt ngang)
        cropW = videoHeight * targetRatio;
        cropX = (videoWidth - cropW) / 2;
    } else {
        // Video cao h∆°n (c·∫ßn c·∫Øt d·ªçc)
        cropH = videoWidth / targetRatio;
        cropY = (videoHeight - cropH) / 2;
    }

    // Canvas s·∫Ω l√† h√¨nh vu√¥ng (W=H) v·ªõi k√≠ch th∆∞·ªõc nh·ªè h∆°n c·ªßa cropW/cropH
    canvas.width = Math.min(cropW, cropH); 
    canvas.height = Math.min(cropW, cropH);
    
    // V·∫Ω ·∫£nh ƒë√£ c·∫Øt t·ª´ video v√†o canvas
    // D√πng transform ƒë·ªÉ l·∫≠t ·∫£nh n·∫øu l√† camera tr∆∞·ªõc
    ctx.save();
    if (currentFacingMode === 'user') {
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
    }

    ctx.drawImage(video, 
        cropX, cropY, cropW, cropH, // Source (t·ª´ video)
        0, 0, canvas.width, canvas.height // Destination (l√™n canvas)
    );
    
    ctx.restore();

    // √Åp d·ª•ng hi·ªáu ·ª©ng film c≈© (n·∫øu c√≥) L√äN ·∫¢NH G·ªêC (tr∆∞·ªõc khi merge)
    // N·∫øu mu·ªën √°p d·ª•ng hi·ªáu ·ª©ng film ngay khi ch·ª•p th√¨ g·ªçi h√†m ·ªü ƒë√¢y
    
    // Ch·ª•p xong th√¨ flash v√† ph√°t √¢m thanh
    flashEffect();
    playShutterSound();
    
    return canvas.toDataURL('image/png');
}


function mergeAndShowFinal() {
    mergeStrip(captures).then(result => {
        showFinal(result);
    }).catch(e => {
        console.error('L·ªói khi gh√©p ·∫£nh:', e);
        finalPreview.innerHTML = '<div class="small" style="color:red">L·ªói khi gh√©p ·∫£nh. Xem console.</div>';
    });
}

function addThumbnail(imgDataUrl, index){
    const wrapper = document.createElement('div');
    wrapper.className = 'instax-thumb-frame';
    wrapper.dataset.index = index;
    wrapper.style.aspectRatio = getInstaxFilmRatio('square') + ' / 1'; 
    
    const img = document.createElement('img');
    img.src = imgDataUrl;
    img.alt = `Pose ${index}`;
    wrapper.appendChild(img);
    
    wrapper.onclick = () => {
        triggerDownload(imgDataUrl, `photobooth_pose_${index}_${dateForFilename()}.png`);
    };
    
    previewGrid.appendChild(wrapper);
}

function dateForFilename(){
    const now = new Date();
    const fmt = new Intl.DateTimeFormat('sv', { timeZone: timeZone, year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit' });
    return fmt.format(now).replace(/[-: ]/g, '').replace('T', '_');
}

function loadImg(dataUrl){
  return new Promise((res, rej) => {
    const i = new Image();
    i.onload = () => res(i);
    i.onerror = rej;
    i.src = dataUrl;
  });
}

// C·∫≠p nh·∫≠t: showFinal nh·∫≠n object { dataUrl, W, H }
function showFinal(result){
  finalPreview.innerHTML = ''; 
  finalImageDataUrl = result.dataUrl; 
  finalActionsEl.style.display = 'flex'; 

  // √Åp d·ª•ng t·ª∑ l·ªá ƒë·ªông ƒë√£ t√≠nh to√°n
  finalPreview.style.aspectRatio = `${result.W} / ${result.H}`;

  const img = document.createElement('img');
  img.src = result.dataUrl;
  finalPreview.appendChild(img);
  
  finalPreview.style.width = 'auto'; 
  finalPreview.style.height = 'auto'; 
}


function resetAll(){
  captures = []; 
  previewGrid.innerHTML = ''; 
  finalPreview.innerHTML = '<div class="small">Ch∆∞a c√≥ ·∫£nh</div>';
  finalImageDataUrl = null; 
  finalActionsEl.style.display = 'none'; 

  // ƒê√£ b·ªè aspect-ratio m·∫∑c ƒë·ªãnh kh·ªèi resetAll
  
  finalPreview.style.width = 'auto';
  finalPreview.style.height = 'auto';

  // K√≠ch ho·∫°t l·∫°i controls sau khi reset
  enableControls(); 
}

function triggerDownload(dataUrl, filename){
  const a = document.createElement('a');
  a.href = dataUrl;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
}

// KH·ªûI T·∫†O
document.addEventListener('DOMContentLoaded', () => {
    if (startPhotoboothBtn) {
        startPhotoboothBtn.addEventListener('click', () => {
            showCaptureScreen();
            startCamera();
        });
    }

    // G·∫Øn s·ª± ki·ªán cho c√°c n√∫t ƒëi·ªÅu khi·ªÉn
    startBtn.addEventListener('click', startPhotobooth);
    redoBtn.addEventListener('click', () => {
        if(confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën RESET t·∫•t c·∫£ ·∫£nh ƒë√£ ch·ª•p v√† b·∫Øt ƒë·∫ßu l·∫°i?')) {
            showWelcomeScreen(); // Quay l·∫°i m√†n h√¨nh welcome ƒë·ªÉ d·ªÖ d√†ng kh·ªüi ƒë·ªông l·∫°i
        }
    });
    stopCamBtn.addEventListener('click', stopCamera);
    switchCamBtn.addEventListener('click', switchCamera);
    refreshBtn.addEventListener('click', () => {
        window.location.reload();
    });
    
    // G·∫Øn s·ª± ki·ªán resize ƒë·ªÉ ƒëi·ªÅu ch·ªânh overlay
    window.addEventListener('resize', resizeOverlay);
});

/* ---------------------------------------------------- */
/* -------------------- DRAWING LOGIC ----------------- */
/* ---------------------------------------------------- */

// Countdown helper (unchanged)
function doCountdown(sec, stepLabel){
  return new Promise(resolve => {
    countdownEl.style.display = 'flex';
    countdownEl.style.flexDirection = 'column';
    
    let timer = sec;
    
    const intervalId = setInterval(() => {
        if (timer > 0) {
            countdownEl.innerHTML = `<span style="font-size: 0.35em; font-weight: 600; margin-bottom: 5px; opacity: 0.8;">${stepLabel}</span><span style="line-height: 1;">${timer}</span>`;
            playBeep();
            timer--;
        } else {
            clearInterval(intervalId);
            countdownEl.style.flexDirection = 'row';
            countdownEl.textContent = '';
            countdownEl.style.display = 'none';
            resolve();
        }
    }, 1000); 
    
  });
}

// NEW: Simple sound/effect for capture
function flashEffect() {
    const flash = document.createElement('div');
    flash.style.cssText = 'position: absolute; inset: 0; background: white; opacity: 0; z-index: 10;';
    document.getElementById('cameraWrap').appendChild(flash);

    flash.animate([
        { opacity: 1, offset: 0 },
        { opacity: 0, offset: 0.5 },
        { opacity: 0, offset: 1 }
    ], {
        duration: 300,
        easing: 'ease-out'
    }).onfinish = () => flash.remove();
}

function playShutterSound() {
    // C√≥ th·ªÉ th√™m √¢m thanh th·ª±c t·∫ø ·ªü ƒë√¢y, v√≠ d·ª•:
    // const audio = new Audio('shutter.mp3');
    // audio.play();
    console.log('Shutter sound played (simulated)');
}

function playBeep() {
    // C√≥ th·ªÉ th√™m √¢m thanh beep th·ª±c t·∫ø ·ªü ƒë√¢y, v√≠ d·ª•:
    // const audio = new Audio('beep.mp3');
    // audio.play();
    console.log('Beep sound played (simulated)');
}


// Draw Photo on Canvas (unchanged)
function drawPhoto(ctx, img, x, y, w, h){
  const imgRatio = img.width / img.height;
  const targetRatio = w / h; // Lu√¥n l√† 1.0 v√¨ W=H=photoW/photoH

  let dw, dh, dx, dy;

  if (imgRatio > targetRatio) {
    // Chi·ªÅu cao l√† gi·ªõi h·∫°n (Crop ngang)
    dh = h;
    dw = h * imgRatio;
    dx = x + (w - dw) / 2;
    dy = y;
  } else {
    // Chi·ªÅu r·ªông l√† gi·ªõi h·∫°n (Crop d·ªçc)
    dw = w;
    dh = w / imgRatio;
    dx = x;
    dy = y + (h - dh) / 2;
  }
  
  // drawImage (crop/cover)
  ctx.drawImage(img, dx, dy, dw, dh);
}

// C·∫¨P NH·∫¨T L·ªöN: Draw Overlay on Photo Area
function drawOverlayFrame(ctx, x, y, w, h, overlayId){
    if (overlayId === 'none') return;
    
    ctx.save();
    
    // Set clip path to the photo area
    ctx.beginPath();
    ctx.rect(x, y, w, h);
    ctx.clip(); 
    
    // --- Helper functions (inside for scope) ---
    
    // Helper function for Noise/Grain (changes pixel data)
    function addGrain(alpha) {
        // C·∫ßn d√πng getImageData/putImageData ƒë·ªÉ thay ƒë·ªïi pixel
        try {
            const imageData = ctx.getImageData(x, y, w, h);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                // T·∫°o nhi·ªÖu ng·∫´u nhi√™n (t·ª´ -25 ƒë·∫øn +25 * alpha)
                const grain = (Math.random() - 0.5) * 50 * alpha; 
                data[i] = data[i] + grain;
                data[i + 1] = data[i + 1] + grain;
                data[i + 2] = data[i + 2] + grain;
            }
            ctx.putImageData(imageData, x, y);
        } catch(e) {
            console.warn('Could not apply addGrain, may be due to CORS on image source if not local:', e);
        }
    }
    
    // Helper function for Sepia color (changes pixel data)
    function applySepia() {
         try {
            const imageData = ctx.getImageData(x, y, w, h);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                // Sepia conversion matrix
                data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189)); // R
                data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168)); // G
                data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131)); // B
            }
            ctx.putImageData(imageData, x, y);
        } catch(e) {
            console.warn('Could not apply applySepia, may be due to CORS on image source if not local:', e);
        }
    }
    
    // Helper for Scratches
    function addScratches(density, color) {
        ctx.strokeStyle = color; 
        ctx.lineWidth = 0.5;
        for (let i = 0; i < 5 * density; i++) {
            const sx = x + Math.random() * w;
            const sy = y + Math.random() * h;
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(sx + Math.random() * 50 - 25, sy + Math.random() * 50 - 25);
            ctx.stroke();
        }
    }

    // --- End Helper functions ---
    
    switch(overlayId) {
        // ---------------------------------
        // --- HI·ªÜU ·ª®NG C√ì S·∫¥N (V√Ä C∆† B·∫¢N) ---
        // ---------------------------------
        case 'heart_corners':
            const size = Math.min(w, h) / 10; // K√≠ch th∆∞·ªõc tr√°i tim
            ctx.fillStyle = '#FF69B4'; // Hot Pink

            const drawHeart = (cx, cy, s) => {
                ctx.beginPath();
                ctx.moveTo(cx, cy + s * 0.3);
                ctx.bezierCurveTo(cx + s * 0.5, cy - s * 0.8, cx + s * 1.0, cy - s * 0.4, cx, cy + s * 0.6);
                ctx.bezierCurveTo(cx - s * 1.0, cy - s * 0.4, cx - s * 0.5, cy - s * 0.8, cx, cy + s * 0.3);
                ctx.fill();
            };

            // 4 g√≥c
            drawHeart(x + size, y + size, size); // Top-Left
            ctx.save();
            ctx.scale(-1, 1);
            drawHeart(-(x + w - size), y + size, size); // Top-Right (mirror X)
            ctx.restore();
            ctx.save();
            ctx.scale(1, -1);
            drawHeart(x + size, -(y + h - size), size); // Bottom-Left (mirror Y)
            ctx.restore();
            ctx.save();
            ctx.scale(-1, -1);
            drawHeart(-(x + w - size), -(y + h - size), size); // Bottom-Right (mirror X, Y)
            ctx.restore();
            break;

        case 'film_damage':
            // Simple film dust/scratches overlay
            ctx.fillStyle = 'rgba(0,0,0,0.1)'; 
            
            // Add dust/specks
            for (let i = 0; i < 50; i++) {
                ctx.fillRect(x + Math.random() * w, y + Math.random() * h, 1, 1);
            }
            
            // Add light scratches
            addScratches(1, 'rgba(255,255,255,0.2)');
            break;
            
        // ---------------------------------
        // --- NHI·ªÑU & C·ªî ƒêI·ªÇN M·ªöI ---
        // ---------------------------------
        case 'film_grain_light':
            addGrain(0.3);
            break;
        case 'film_grain_heavy':
            addGrain(0.8);
            break;
        case 'vintage_sepia_light':
            // Sepia
            applySepia();
            // Subtle White overlay for fading
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(x, y, w, h);
            break;
        case 'faded_matte':
            // Subtle black/white grain simulation
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(x, y, w, h);
            // Apply a slight fade to the edges (simulated vignette)
            const fadeGrad = ctx.createRadialGradient(x + w/2, y + h/2, Math.min(w,h)*0.3, x + w/2, y + h/2, Math.min(w,h)*0.6);
            fadeGrad.addColorStop(0, 'rgba(0,0,0,0)');
            fadeGrad.addColorStop(1, 'rgba(0,0,0,0.2)');
            ctx.fillStyle = fadeGrad;
            ctx.fillRect(x, y, w, h);
            break;
        case 'dust_scratches_medium':
            // Dust
            ctx.fillStyle = 'rgba(0,0,0,0.15)'; 
            for (let i = 0; i < 100; i++) {
                ctx.fillRect(x + Math.random() * w, y + Math.random() * h, 1, 1);
            }
            // Scratches
            addScratches(2, 'rgba(255,255,255,0.4)');
            break;
            
        // ---------------------------------
        // --- √ÅNH S√ÅNG M·ªöI ---
        // ---------------------------------
        case 'golden_light_leak':
            ctx.globalCompositeOperation = 'lighter';
            const leakGrad = ctx.createRadialGradient(x, y, 0, x, y, w*1.2);
            leakGrad.addColorStop(0, 'rgba(255, 223, 0, 0.5)'); // Bright Gold
            leakGrad.addColorStop(0.3, 'rgba(255, 255, 255, 0.1)');
            leakGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = leakGrad;
            ctx.beginPath();
            ctx.arc(x, y, w * 1.5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
            break;
        case 'sunset_light_leak':
            ctx.globalCompositeOperation = 'lighter';
            const sunsetGrad = ctx.createLinearGradient(x, y + h, x + w, y);
            sunsetGrad.addColorStop(0, 'rgba(255, 100, 0, 0.4)'); // Orange
            sunsetGrad.addColorStop(0.5, 'rgba(255, 200, 0, 0.3)'); // Yellow
            sunsetGrad.addColorStop(1, 'rgba(255, 0, 100, 0.2)'); // Pink
            ctx.fillStyle = sunsetGrad;
            ctx.fillRect(x, y, w, h);
            ctx.globalCompositeOperation = 'source-over';
            break;
        case 'soft_bokeh':
            // Simulation: draw a few blurred circles
            ctx.globalCompositeOperation = 'overlay';
            ctx.globalAlpha = 0.5;
            const bokehColors = ['#FFC0CB', '#ADD8E6', '#90EE90'];
            for(let i=0; i<5; i++) {
                const cx = x + Math.random() * w;
                const cy = y + Math.random() * h;
                const r = Math.min(w,h) * (Math.random() * 0.1 + 0.05);
                ctx.fillStyle = bokehColors[i % 3];
                // Faking blur with transparent radial gradient
                const bGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
                bGrad.addColorStop(0, ctx.fillStyle);
                bGrad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = bGrad;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                ctx.fill();
            }
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;
            break;
        case 'blue_vignette':
            const blueGrad = ctx.createRadialGradient(x + w/2, y + h/2, Math.min(w,h)*0.3, x + w/2, y + h/2, Math.min(w,h)*0.6);
            blueGrad.addColorStop(0, 'rgba(0,0,100,0)');
            blueGrad.addColorStop(1, 'rgba(0,0,50,0.5)'); // Dark Blue
            ctx.fillStyle = blueGrad;
            ctx.fillRect(x, y, w, h);
            break;
        case 'rainbow_prism':
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = 0.3;
            const prismGrad = ctx.createLinearGradient(x, y, x + w, y + h);
            prismGrad.addColorStop(0, 'red');
            prismGrad.addColorStop(0.2, 'orange');
            prismGrad.addColorStop(0.4, 'yellow');
            prismGrad.addColorStop(0.6, 'green');
            prismGrad.addColorStop(0.8, 'blue');
            prismGrad.addColorStop(1, 'purple');
            ctx.fillStyle = prismGrad;
            ctx.fillRect(x, y, w, h);
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;
            break;
        case 'film_burn_top':
            const burnGrad = ctx.createLinearGradient(x, y, x, y + h/2);
            burnGrad.addColorStop(0, 'rgba(255, 0, 0, 0.6)');
            burnGrad.addColorStop(0.3, 'rgba(255, 165, 0, 0.3)');
            burnGrad.addColorStop(0.5, 'rgba(255, 255, 0, 0.1)');
            burnGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = burnGrad;
            ctx.fillRect(x, y, w, h);
            break;
            
        // ---------------------------------
        // --- KHUNG & H√åNH D·∫†NG M·ªöI ---
        // ---------------------------------
        case 'polaroid_border_thin':
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 10;
            ctx.strokeRect(x + ctx.lineWidth/2, y + ctx.lineWidth/2, w - ctx.lineWidth, h - ctx.lineWidth);
            break;
        case 'black_frame_thin':
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.lineWidth = 8;
            ctx.strokeRect(x + ctx.lineWidth/2, y + ctx.lineWidth/2, w - ctx.lineWidth, h - ctx.lineWidth);
            break;
        case 'white_cross_hatch':
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            for(let i=0; i<w; i+=20) {
                ctx.beginPath();
                ctx.moveTo(x + i, y);
                ctx.lineTo(x + i, y + h);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(x, y + i * (h/w));
                ctx.lineTo(x + w, y + i * (h/w));
                ctx.stroke();
            }
            break;
        case 'heart_shaped_mask':
            // ƒê·ªÉ t·∫°o l·ªó h·ªïng, ta ph·∫£i t·∫Øt clip path hi·ªán t·∫°i, v·∫Ω h√¨nh tr√°i tim, sau ƒë√≥ b·∫≠t l·∫°i clip path
            ctx.restore(); // Ph·ª•c h·ªìi clip path (t·ª©c l√† kh√¥ng c√≤n clip path n·ªØa)
            ctx.save(); // L∆∞u tr·∫°ng th√°i
            
            // K√≠ch th∆∞·ªõc v√† v·ªã tr√≠ tr√°i tim
            const heartSize = Math.min(w,h) * 0.9;
            const heartX = x + w/2;
            const heartY = y + h/2;
            
            // 1. S·ª≠ d·ª•ng globalCompositeOperation = 'destination-out' ƒë·ªÉ l√†m trong su·ªët khu v·ª±c v·∫Ω
            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillStyle = '#000000'; 
            
            // V·∫Ω h√¨nh tr√°i tim
            ctx.beginPath();
            ctx.moveTo(heartX, heartY + heartSize * 0.3);
            ctx.bezierCurveTo(heartX + heartSize * 0.5, heartY - heartSize * 0.8, heartX + heartSize * 1.0, heartY - heartSize * 0.4, heartX, heartY + heartSize * 0.6);
            ctx.bezierCurveTo(heartX - heartSize * 1.0, heartY - heartSize * 0.4, heartX - heartSize * 0.5, heartY - heartSize * 0.8, heartX, heartY + heartSize * 0.3);
            ctx.closePath();
            ctx.fill(); // Fill tr√°i tim (t·∫°o l·ªó h·ªïng)
            
            ctx.globalCompositeOperation = 'source-over'; // Tr·ªü l·∫°i ch·∫ø ƒë·ªô v·∫Ω b√¨nh th∆∞·ªùng
            
            // 2. V·∫Ω vi·ªÅn tr·∫Øng xung quanh l·ªó h·ªïng
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(heartX, heartY + heartSize * 0.3);
            ctx.bezierCurveTo(heartX + heartSize * 0.5, heartY - heartSize * 0.8, heartX + heartSize * 1.0, heartY - heartSize * 0.4, heartX, heartY + heartSize * 0.6);
            ctx.bezierCurveTo(heartX - heartSize * 1.0, heartY - heartSize * 0.4, heartX - heartSize * 0.5, heartY - heartSize * 0.8, heartX, heartY + heartSize * 0.3);
            ctx.closePath();
            ctx.stroke();
            
            // 3. Kh√¥i ph·ª•c clip path cho c√°c l·∫ßn g·ªçi drawOverlayFrame ti·∫øp theo (n·∫øu c√≥)
            ctx.restore(); 
            ctx.beginPath();
            ctx.rect(x, y, w, h);
            ctx.clip(); 
            break;
        case 'scribble_corners':
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 3;
            
            const scribble = (sx, sy, isX, isY) => {
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                const len = Math.min(w, h) * 0.15;
                // Simple scribble simulation
                ctx.lineTo(sx + (isX ? len : 0), sy + (isY ? len : 0));
                ctx.lineTo(sx + (isX ? len*0.8 : 0), sy + (isY ? len*0.5 : 0));
                ctx.lineTo(sx + (isX ? len*1.2 : 0), sy + (isY ? len*0.2 : 0));
                ctx.stroke();
            };
            
            // Top Left
            scribble(x + 5, y + 5, true, true);
            // Top Right
            ctx.save(); ctx.scale(-1, 1); scribble(-(x + w - 5), y + 5, true, true); ctx.restore();
            // Bottom Left
            ctx.save(); ctx.scale(1, -1); scribble(x + 5, -(y + h - 5), true, true); ctx.restore();
            // Bottom Right
            ctx.save(); ctx.scale(-1, -1); scribble(-(x + w - 5), -(y + h - 5), true, true); ctx.restore();
            break;
        case 'tape_strip_top':
            // White translucent tape strip at the top
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            const tapeH = h * 0.1;
            ctx.fillRect(x - 5, y, w + 10, tapeH);
            
            // Faking torn edges with small rectangles
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for(let i=0; i<w/10; i++) {
                ctx.fillRect(x + i*10 - 5, y + tapeH - 2 + Math.random()*4, 10, 2);
            }
            break;
            
        // ---------------------------------
        // --- HI·ªÜU ·ª®NG ƒê·∫∂C BI·ªÜT M·ªöI ---
        // ---------------------------------
        case 'holographic_glitch':
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = 0.5;
            // Draw some colored scan lines
            for(let i=0; i<h; i+=10) {
                const color = ['#FF00FF', '#00FFFF', '#FFFF00'][Math.floor(Math.random() * 3)];
                ctx.fillStyle = color;
                ctx.fillRect(x, y + i, w, 2);
            }
            
            // Shift small areas for glitch effect (requires pixel manipulation, may fail with CORS)
            try {
                const imageData = ctx.getImageData(x, y, w, h);
                const data = imageData.data;
                for(let i=0; i<5; i++) {
                    const startY = Math.floor(Math.random() * h * 0.8);
                    const blockH = Math.floor(Math.random() * 10) + 5;
                    const shift = Math.floor(Math.random() * 20) - 10;
                    
                    if (shift !== 0) {
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = w;
                        tempCanvas.height = blockH;
                        const tempCtx = tempCanvas.getContext('2d');
                        
                        const blockData = ctx.getImageData(x, y + startY, w, blockH);
                        tempCtx.putImageData(blockData, 0, 0);
                        
                        ctx.clearRect(x, y + startY, w, blockH);
                        ctx.drawImage(tempCanvas, x + shift, y + startY);
                    }
                }
            } catch(e) {
                console.warn('Could not apply glitch shift due to CORS or other error:', e);
            }
            
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;
            break;
        case 'half_tone_dots':
            // Simple simulation of a halftone pattern
            const dotSize = 8;
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            for(let i=0; i<w; i+=dotSize) {
                for(let j=0; j<h; j+=dotSize) {
                    const radius = dotSize * 0.4 * (Math.random() * 0.5 + 0.5); // Randomize dot size slightly
                    ctx.beginPath();
                    ctx.arc(x + i + dotSize/2, y + j + dotSize/2, radius, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            ctx.globalCompositeOperation = 'source-over';
            break;
        case 'glitter_sparkle':
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = 0.8;
            for(let i=0; i<200; i++) {
                const color = ['#FFD700', '#FFFFFF', '#FFC0CB'][Math.floor(Math.random() * 3)];
                const cx = x + Math.random() * w;
                const cy = y + Math.random() * h;
                const size = Math.random() * 2 + 1;
                ctx.fillStyle = color;
                ctx.fillRect(cx, cy, size, size);
            }
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;
            break;
            
        default: 
            // Do nothing
            break;
    }
    
    ctx.restore(); 
}

// Draw Overlay on Photo Area (unchanged)
function drawOverlayFrame_ORIGINAL(ctx, x, y, w, h, overlayId){
    if (overlayId === 'none') return;
    
    ctx.save();
    
    // Set clip path to the photo area
    ctx.beginPath();
    ctx.rect(x, y, w, h);
    ctx.clip(); 
    
    if (overlayId === 'heart_corners') {
        const size = Math.min(w, h) / 10; // K√≠ch th∆∞·ªõc tr√°i tim
        ctx.fillStyle = '#FF69B4'; // Hot Pink

        const drawHeart = (cx, cy, s) => {
            ctx.beginPath();
            ctx.moveTo(cx, cy + s * 0.3);
            ctx.bezierCurveTo(cx + s * 0.5, cy - s * 0.8, cx + s * 1.0, cy - s * 0.4, cx, cy + s * 0.6);
            ctx.bezierCurveTo(cx - s * 1.0, cy - s * 0.4, cx - s * 0.5, cy - s * 0.8, cx, cy + s * 0.3);
            ctx.fill();
        };

        // 4 g√≥c
        drawHeart(x + size, y + size, size); // Top-Left
        ctx.save();
        ctx.scale(-1, 1);
        drawHeart(-(x + w - size), y + size, size); // Top-Right (mirror X)
        ctx.restore();
        ctx.save();
        ctx.scale(1, -1);
        drawHeart(x + size, -(y + h - size), size); // Bottom-Left (mirror Y)
        ctx.restore();
        ctx.save();
        ctx.scale(-1, -1);
        drawHeart(-(x + w - size), -(y + h - size), size); // Bottom-Right (mirror X, Y)
        ctx.restore();

    } else if (overlayId === 'film_damage') {
        // Simple film dust/scratches overlay
        ctx.fillStyle = 'rgba(0,0,0,0.1)'; 
        
        // Add dust/specks
        for (let i = 0; i < 50; i++) {
            ctx.fillRect(x + Math.random() * w, y + Math.random() * h, 1, 1);
        }
        
        // Add light scratches
        ctx.strokeStyle = 'rgba(255,255,255,0.2)'; 
        ctx.lineWidth = 0.5;
        for (let i = 0; i < 5; i++) {
            const sx = x + Math.random() * w;
            const sy = y + Math.random() * h;
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(sx + Math.random() * 50 - 25, sy + Math.random() * 50 - 25);
            ctx.stroke();
        }
    }
    
    ctx.restore(); 
}

// **ƒê√É S·ª¨A L·ªñI MERGE (L·ªói 2):** ƒê·ªïi t√™n tham s·ªë cho nh·∫•t qu√°n.
// H√†m n√†y gi·ªù nh·∫≠n YStart v√† TextH ƒë√£ t√≠nh to√°n s·∫µn.
function drawComplexBackground(ctx, W, H, backgroundId, layout, textStripYStart, textStripHeight){
    ctx.save();
    
    // ƒê·∫£m b·∫£o to√†n b·ªô canvas ƒë∆∞·ª£c fill m√†u tr·∫Øng ho·∫∑c m√†u n·ªÅn ch√≠nh
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(0, 0, W, H);
    
    if (backgroundId === 'soft_rose_gradient') {
        const grad = ctx.createLinearGradient(0, 0, W, H);
        grad.addColorStop(0, '#FFD1DC'); 
        grad.addColorStop(1, '#FFEBCD'); 
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);
    } else if (backgroundId === 'romantic_red_velvet') {
        ctx.fillStyle = '#8B0000'; // Dark Red
        ctx.fillRect(0, 0, W, H);
    } else if (backgroundId === 'lavender_haze_blur') {
        const grad = ctx.createLinearGradient(0, 0, W, H);
        grad.addColorStop(0, '#E6E6FA'); // Lavender
        grad.addColorStop(1, '#B0E0E6'); // Powder Blue
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);
    } else if (backgroundId === 'sweetheart_pink_dots') {
        const patternCanvas = document.createElement('canvas');
        const patternSize = 60;
        patternCanvas.width = patternSize;
        patternCanvas.height = patternSize;
        const pCtx = patternCanvas.getContext('2d');
        pCtx.fillStyle = '#FFFFFF';
        pCtx.fillRect(0, 0, patternSize, patternSize);
        const drawMiniHeart = (cx, cy, s) => {
            pCtx.beginPath();
            pCtx.moveTo(cx, cy + s * 0.3);
            pCtx.bezierCurveTo(cx + s * 0.5, cy - s * 0.8, cx + s * 1.0, cy - s * 0.4, cx, cy + s * 0.6);
            pCtx.bezierCurveTo(cx - s * 1.0, cy - s * 0.4, cx - s * 0.5, cy - s * 0.8, cx, cy + s * 0.3);
            pCtx.fill();
        };
        pCtx.fillStyle = '#FFB6C1'; // Light Pink
        drawMiniHeart(patternSize * 0.25, patternSize * 0.25, 4);
        pCtx.fillStyle = '#FF69B4'; // Hot Pink
        drawMiniHeart(patternSize * 0.75, patternSize * 0.75, 3);
        const pattern = ctx.createPattern(patternCanvas, 'repeat');
        ctx.fillStyle = pattern;
        ctx.fillRect(0, 0, W, H);
    } else if (backgroundId === 'sunset_kiss_gradient') {
        const grad = ctx.createLinearGradient(0, H, W, 0);
        grad.addColorStop(0, '#FF4D4D'); // Red-Orange
        grad.addColorStop(0.5, '#FFD700'); // Gold/Yellow
        grad.addColorStop(1, '#FFC0CB'); // Pink
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);
    } else if (backgroundId === 'champagne_toast') {
        const grad = ctx.createLinearGradient(0, 0, W, H);
        grad.addColorStop(0, '#F5DEB3'); // Wheat
        grad.addColorStop(0.5, '#FFFACD'); // Lemon Chiffon
        grad.addColorStop(1, '#FFE4E1'); // Misty Rose
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);
    } else if (backgroundId === 'blush_watercolor') {
        ctx.fillStyle = '#FEE5E2'; // Very Pale Pink
        ctx.fillRect(0, 0, W, H);
        const spots = [
            { x: W * 0.1, y: H * 0.2, r: W * 0.1, color: 'rgba(255,192,203,0.5)' },
            { x: W * 0.8, y: H * 0.6, r: W * 0.15, color: 'rgba(255,160,192,0.4)' },
            { x: W * 0.4, y: H * 0.9, r: W * 0.08, color: 'rgba(255,105,180,0.3)' }
        ];
        spots.forEach(spot => {
            const grad = ctx.createRadialGradient(spot.x, spot.y, 0, spot.x, spot.y, spot.r);
            grad.addColorStop(0, spot.color);
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(spot.x, spot.y, spot.r, 0, 2 * Math.PI);
            ctx.fill();
        });
    } else if (backgroundId === 'mint_love_stripes') {
        const colorA = '#F0FFF0'; // Honeydew
        const colorB = '#98FB98'; // Pale Green
        const stripeHeight = H / 20; 
        for (let i = 0; i < 20; i++) {
            ctx.fillStyle = i % 2 === 0 ? colorA : colorB;
            ctx.fillRect(0, i * stripeHeight, W, stripeHeight);
        }
        // Footer (Text Strip) v·∫´n l√† m√†u stripes
    } else if (backgroundId === 'starry_night_light') {
        ctx.fillStyle = '#191970'; // Midnight Blue
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        for (let i = 0; i < 150; i++) {
            ctx.fillRect(Math.random() * W, Math.random() * H, 1, 1);
        }
    } else if (backgroundId === 'coral_dream') {
        ctx.fillStyle = '#FF7F50'; // Coral
        ctx.fillRect(0, 0, W, H);
    } else if (backgroundId === 'berry_smoothie') {
        const grad = ctx.createLinearGradient(W/2, 0, W/2, H);
        grad.addColorStop(0, '#DA70D6'); // Orchid
        grad.addColorStop(1, '#BA55D3'); // Medium Orchid
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);
    } else if (backgroundId === 'lilac_blossom_texture') {
        ctx.fillStyle = '#E6E6FA'; // Lavender
        ctx.fillRect(0, 0, W, H);
        const noiseCanvas = document.createElement('canvas');
        noiseCanvas.width = 100;
        noiseCanvas.height = 100;
        const nCtx = noiseCanvas.getContext('2d');
        for (let i = 0; i < 3000; i++) {
            nCtx.fillStyle = `rgba(0, 0, 0, ${Math.random() * 0.02})`; // Very subtle dark noise
            nCtx.fillRect(Math.random() * 100, Math.random() * 100, 1, 1);
        }
        const pattern = ctx.createPattern(noiseCanvas, 'repeat');
        ctx.fillStyle = pattern;
        ctx.fillRect(0, 0, W, H);
    } else if (backgroundId === 'peachy_glow') {
        const grad = ctx.createLinearGradient(0, H, W, 0);
        grad.addColorStop(0, '#FFDAB9'); // Peach Puff
        grad.addColorStop(1, '#FFC0CB'); // Pink
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);
    } else if (backgroundId === 'cotton_candy_swirl') {
        const grad = ctx.createLinearGradient(0, 0, W, H);
        grad.addColorStop(0, '#ADD8E6'); // Light Blue
        grad.addColorStop(0.5, '#FFB6C1'); // Light Pink
        grad.addColorStop(1, '#F0E68C'); // Khaki
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);
    } else if (backgroundId === 'valentines_day_hearts') {
        ctx.fillStyle = '#FFFFFF'; 
        ctx.fillRect(0, 0, W, H);
        const patternCanvas = document.createElement('canvas');
        const patternSize = 80;
        patternCanvas.width = patternSize;
        patternCanvas.height = patternSize;
        const pCtx = patternCanvas.getContext('2d');
        pCtx.fillStyle = '#F0F0F0'; 
        pCtx.fillRect(0, 0, patternSize, patternSize);
        pCtx.fillStyle = '#FF69B4'; // Hot Pink
        const drawSmallHeart = (cx, cy, s) => {
            pCtx.beginPath();
            pCtx.moveTo(cx, cy + s * 0.3);
            pCtx.bezierCurveTo(cx + s * 0.5, cy - s * 0.8, cx + s * 1.0, cy - s * 0.4, cx, cy + s * 0.6);
            pCtx.bezierCurveTo(cx - s * 1.0, cy - s * 0.4, cx - s * 0.5, cy - s * 0.8, cx, cy + s * 0.3);
            pCtx.fill();
        };
        drawSmallHeart(patternSize * 0.25, patternSize * 0.25, 4);
        drawSmallHeart(patternSize * 0.75, patternSize * 0.5, 3);
        const pattern = ctx.createPattern(patternCanvas, 'repeat');
        ctx.fillStyle = pattern;
        ctx.fillRect(0, 0, W, H);
    } else if (backgroundId === 'aurora_pink_blue') {
        const grad = ctx.createLinearGradient(0, H, W, 0);
        grad.addColorStop(0, '#00BFFF'); // Deep Sky Blue
        grad.addColorStop(0.5, '#FFFFFF');
        grad.addColorStop(1, '#FF69B4'); // Hot Pink
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);
    } else if (backgroundId === 'lemonade_pink') {
        const grad = ctx.createLinearGradient(0, 0, W, H);
        grad.addColorStop(0, '#FFD700'); // Gold
        grad.addColorStop(0.7, '#FFC0CB'); // Pink
        grad.addColorStop(1, '#FFFFFF');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);
    } else if (backgroundId === 'dreamy_cloud_pastel') {
        ctx.fillStyle = '#F0F8FF'; // Alice Blue
        ctx.fillRect(0, 0, W, H);
        // Soft clouds texture
        const patternCanvas = document.createElement('canvas');
        const patternSize = 150;
        patternCanvas.width = patternSize;
        patternCanvas.height = patternSize;
        const pCtx = patternCanvas.getContext('2d');
        pCtx.fillStyle = '#F0F8FF';
        pCtx.fillRect(0, 0, patternSize, patternSize);
        pCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        pCtx.beginPath();
        pCtx.arc(30, 30, 20, 0, 2 * Math.PI);
        pCtx.fill();
        pCtx.beginPath();
        pCtx.arc(120, 80, 40, 0, 2 * Math.PI);
        pCtx.fill();
        const pattern = ctx.createPattern(patternCanvas, 'repeat');
        ctx.fillStyle = pattern;
        ctx.fillRect(0, 0, W, H);
    } else if (backgroundId === 'minimal_white_texture') {
        ctx.fillStyle = '#FFFFFF'; 
        ctx.fillRect(0, 0, W, H);
        const noiseCanvas = document.createElement('canvas');
        noiseCanvas.width = 100;
        noiseCanvas.height = 100;
        const nCtx = noiseCanvas.getContext('2d');
        for (let i = 0; i < 5000; i++) {
            nCtx.fillStyle = `rgba(0, 0, 0, ${Math.random() * 0.01})`; 
            nCtx.fillRect(Math.random() * 100, Math.random() * 100, 1, 1);
        }
        const pattern = ctx.createPattern(noiseCanvas, 'repeat');
        ctx.fillStyle = pattern;
        ctx.fillRect(0, 0, W, H);
    } else if (backgroundId === 'stripes_bw') {
        const colorA = '#FFFFFF'; 
        const colorB = '#333333';
        const stripeHeight = H / 25; 
        for (let i = 0; i < 25; i++) {
            ctx.fillStyle = i % 2 === 0 ? colorA : colorB;
            ctx.fillRect(0, i * stripeHeight, W, stripeHeight);
        }
    } else if (backgroundId === 'fuji_classic_clean') {
        // 1. ƒê·∫£m b·∫£o to√†n b·ªô n·ªÅn l√† m√†u tr·∫Øng (ho·∫∑c r·∫•t nh·∫°t)
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, W, H);
        // 2. V·∫Ω d·∫£i m√†u ·ªü khu v·ª±c Footer/Text Strip (M√†u xanh Fuji nh·∫π nh√†ng)
        const fujiFooterColor = '#B3D0FF'; // M√†u xanh nh·∫°t (Light Fuji Blue)
        ctx.fillStyle = fujiFooterColor;
        // S·ª≠ d·ª•ng textStripHeight ƒë√£ ƒë∆∞·ª£c t√≠nh to√°n ch√≠nh x√°c
        ctx.fillRect(0, textStripYStart, W, textStripHeight); 
    } else {
        // M·∫∑c ƒë·ªãnh (default) - n·ªÅn tr·∫Øng
        ctx.fillStyle = '#FFFFFF'; 
        ctx.fillRect(0, 0, W, H);
    }
    
    ctx.restore();
}

// H√†m l·∫•y m√†u n·ªÅn film Instax m·∫∑c ƒë·ªãnh
function getFilmColor(frameStyle, backgroundId) {
    if (backgroundId !== 'default') return '#FFFFFF'; 
    // N·∫øu l√† background m·∫∑c ƒë·ªãnh, b√¢y gi·ªù s·∫Ω d√πng m√†u tr·∫Øng v√¨ ƒë√£ b·ªè vi·ªÅn Instax
    return '#FFFFFF';
}

async function mergeStrip(images){
    const layout = layoutSelect.value;
    // ƒê√£ b·ªè frameSelect. C·ªë ƒë·ªãnh t·ª∑ l·ªá ·∫£nh ch·ª•p (photo area) l√† 1:1 (Square)
    const frameStyle = 'square'; 
    const backgroundId = backgroundSelect.value;
    const overlayId = overlaySelect.value; 
    
    let W, H; 
    
    // T·ª∑ l·ªá ·∫¢nh B√äN TRONG (Photo Area Ratio) c·ªë ƒë·ªãnh 1:1
    const targetRatio = 1.0; 
    
    // S·ª≠ d·ª•ng BASE_FRAME_H (450px) l√†m Chi·ªÅu cao C·ªë ƒë·ªãnh c·ªßa 1 t·∫•m ·∫£nh (PHOTO)
    const photoH = BASE_FRAME_H; // 450
    const photoW = Math.round(photoH * targetRatio); // 450 (C·ªë ƒë·ªãnh 1:1)
    
    // C√†i ƒë·∫∑t margins
    const stripMarginX = VERT_MARGIN_X; // Margin X cho strip d·ªçc (30)
    // S·ª¨A: L·∫•y VERT_MARGIN_Y ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t
    const vertMarginY = VERT_MARGIN_Y; // Margin Y cho kh·ªëi ·∫£nh strip d·ªçc (40)
    const vertTextH = VERT_TEXT_H; // Chi·ªÅu cao khu v·ª±c ch·ªØ strip d·ªçc
    
    const gridOuterPadding = GRID_OUTER_PADDING; // L·ªÅ ngo√†i cho l∆∞·ªõi (40)
    const gridGap = GRID_GAP; // Kho·∫£ng c√°ch gi·ªØa c√°c ·∫£nh (ngang/d·ªçc) (30)
    const gridTextH = GRID_TEXT_H; // Chi·ªÅu cao khu v·ª±c ch·ªØ cho l∆∞·ªõi

    // 1. T√≠nh to√°n K√≠ch th∆∞·ªõc Canvas (W x H) v√† v·ªã tr√≠ Text Strip
    let textStripYStart;
    let textStripTotalHeight; 

    if (layout === 'vertical') {
        // Vertical Strip (4x1) - BORDERLESS
        const numPhotos = images.length;
        const numGaps = numPhotos - 1;
        
        W = photoW + stripMarginX * 2; // 450 + 60 = 510
        // C·∫¨P NH·∫¨T: Th√™m VERT_MARGIN_Y v√†o chi·ªÅu cao total H
        H = numPhotos * photoH + numGaps * VERT_GAP + vertTextH + vertMarginY * 2; 
        
        // C·∫¨P NH·∫¨T: textStripYStart = L·ªÅ tr√™n + (·∫¢nh + Kho·∫£ng c√°ch) * 4
        textStripYStart = vertMarginY + numPhotos * photoH + numGaps * VERT_GAP; 
        textStripTotalHeight = vertTextH + vertMarginY; // Chi·ªÅu cao khu v·ª±c ch·ªØ + l·ªÅ d∆∞·ªõi
        
        stripSizeText.textContent = `Strip size: ${W} x ${H} pixels (Fixed 1:1 Photo)`;
    } else { 
        // Grid (2x2) - BORDERLESS
        W = 2 * photoW + gridGap + 2 * gridOuterPadding; // 2*450 + 30 + 80 = 1010
        H = 2 * photoH + gridGap + 2 * gridOuterPadding + gridTextH; // 2*450 + 30 + 80 + 250 = 1260
        textStripYStart = 2 * photoH + gridGap + 2 * gridOuterPadding; // Y start of text area: 1010
        textStripTotalHeight = gridTextH; // Chi·ªÅu cao khu v·ª±c ch·ªØ
        
        stripSizeText.textContent = `Grid size: ${W} x ${H} pixels (Fixed 1:1 Photo)`;
    }
    
    // NEW: T√≠nh to√°n ch√≠nh x√°c chi·ªÅu cao khu v·ª±c ch·ªØ (Ch·∫Øc ch·∫Øn ƒë√£ ƒë∆∞·ª£c t√≠nh)
    const textStripHeight = H - textStripYStart; 
    // D√πng textStripHeight ƒë·ªÉ g·ªçi h√†m v·∫Ω background
    
    // 2. Setup Canvas
    const canvas = document.createElement('canvas');
    canvas.width = W;
    canvas.height = H;
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingQuality = 'high';

    // 3. Draw Background
    // ƒê√£ c·∫≠p nh·∫≠t ƒë·ªÉ truy·ªÅn TextStripYStart v√† TextStripHeight
    drawComplexBackground(ctx, W, H, backgroundId, layout, textStripYStart, textStripHeight); 

    // Logic ƒëi·ªÅu ch·ªânh m√†u ch·ªØ
    let instaxTextColor = '#4A4A4A'; 
    let innerBorderColor = '#4A4A4A'; 
    
    // T·∫°m th·ªùi b·ªè qua logic m√†u film m·∫∑c ƒë·ªãnh
    if (backgroundId !== 'default') {
        if (backgroundId === 'romantic_red_velvet' || backgroundId === 'starry_night_light' || backgroundId === 'berry_smoothie' || backgroundId === 'coral_dream') { 
            instaxTextColor = '#FFFFFF'; 
            innerBorderColor = '#FFFFFF'; 
        } else if (backgroundId === 'stripes_bw') { 
            instaxTextColor = '#FFFFFF'; 
            innerBorderColor = '#FFFFFF';
        } else if (backgroundId === 'fuji_classic_clean') { 
            instaxTextColor = '#333333'; 
            innerBorderColor = '#333333'; 
        }
    } else {
        // N·∫øu l√† default, n·ªÅn tr·∫Øng, ch·ªØ ƒëen
        ctx.fillStyle = getFilmColor(frameStyle, backgroundId); // GetFilmColor gi·ªù l√† White
        ctx.fillRect(0,0,W,H);
    }
    
    // 4. Draw Photos
    const imagesToProcess = await Promise.all(images.map(loadImg)); 

    for (let i=0; i < imagesToProcess.length; i++) {
        const img = imagesToProcess[i];
        
        let finalImageX, finalImageY;
        
        if (layout === 'vertical') {
            finalImageX = stripMarginX;
            // C·∫¨P NH·∫¨T: Th√™m vertMarginY (l·ªÅ tr√™n) v√†o c√¥ng th·ª©c
            finalImageY = vertMarginY + i * photoH + i * VERT_GAP; 
        } else { // Grid
            const col = i % 2;
            const row = Math.floor(i / 2);
            
            finalImageX = gridOuterPadding + col * (photoW + gridGap); 
            finalImageY = gridOuterPadding + row * (photoH + gridGap); 
        }
        
        // DRAW Photo (Border-less) - C√≥ th√™m vi·ªÅn n·ªôi 3px
        ctx.fillStyle = innerBorderColor;
        ctx.fillRect(finalImageX - INNER_BORDER, finalImageY - INNER_BORDER, photoW + 2*INNER_BORDER, photoH + 2*INNER_BORDER);
        
        drawPhoto(ctx, img, finalImageX, finalImageY, photoW, photoH);
        
        // DRAW Overlay
        drawOverlayFrame(ctx, finalImageX, finalImageY, photoW, photoH, overlayId);
    }
    
    // 5. Text Strip Logic (V·∫Ω ch·ªØ)
    const customText = customStripText.value.toUpperCase(); 

    ctx.save();
    ctx.textAlign = 'center';
    
    // V·ªã tr√≠ ch·ªØ (cƒÉn gi·ªØa khu v·ª±c Text Strip)
    const centerX = W / 2;
    // S·ª≠ d·ª•ng chi·ªÅu cao Text Strip ƒë√£ t√≠nh to√°n (textStripHeight)
    const centerY = textStripYStart + textStripHeight / 2; 
    
    // T√≠nh k√≠ch th∆∞·ªõc ch·ªØ (ƒë·ªÉ co gi√£n n·∫øu qu√° d√†i)
    let fontSize = 50; 
    ctx.font = `800 ${fontSize}px Nunito, system-ui, sans-serif`; 
    let textWidth = ctx.measureText(customText).width;
    const maxTextWidth = W * 0.9; 
    
    if (textWidth > maxTextWidth) {
        fontSize = Math.floor(fontSize * (maxTextWidth / textWidth));
        ctx.font = `800 ${fontSize}px Nunito, system-ui, sans-serif`; 
    }
    
    // V·ªã tr√≠ y cho text (cƒÉn gi·ªØa theo font size)
    const textY = centerY + fontSize * 0.3; // D√πng 0.3 ƒë·ªÉ cƒÉn gi·ªØa t·ªët h∆°n

    ctx.fillStyle = instaxTextColor; // M√†u ch·ªØ
    ctx.fillText(customText, centerX, textY);
    
    // ƒê√É X√ìA: Logic v·∫Ω sticker/date
    
    ctx.restore(); 

    // 6. V·∫Ω Vi·ªÅn Ngo·∫°i C√πng
    ctx.strokeStyle = '#444444'; 
    ctx.lineWidth = 4;
    ctx.strokeRect(2, 2, W-4, H-4); 

    // 7. V·∫Ω Ng√†y Gi·ªù ·ªü d∆∞·ªõi c√πng
    ctx.save();
    ctx.font = '600 16px Nunito, system-ui, sans-serif';
    ctx.fillStyle = (backgroundId === 'default' ? 'rgba(60,70,90,0.7)' : 'rgba(255,255,255,0.7)'); 

    // ƒê·∫∑c bi·ªát cho Fuji Clean ho·∫∑c n·ªÅn ƒë·∫≠m
    if (backgroundId === 'fuji_classic_clean' || backgroundId === 'romantic_red_velvet' || backgroundId === 'starry_night_light' || backgroundId === 'berry_smoothie' || backgroundId === 'coral_dream') { 
        ctx.fillStyle = '#FFFFFF';
    } else if (backgroundId === 'minimal_white_texture' || backgroundId === 'default') {
        ctx.fillStyle = 'rgba(60,70,90,0.7)';
    }

    ctx.textAlign = 'left';
    ctx.fillText(getFormattedNow(), 16, H - 18);
    ctx.restore();

    // S·ª¨A L·ªñI: S·ª≠ d·ª•ng canvas.toDataURL thay v√¨ ctx.toDataURL
    return { dataUrl: canvas.toDataURL('image/png'), W: W, H: H };
}
</script>